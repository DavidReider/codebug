"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _flatten2 = _interopRequireDefault(require("lodash/flatten"));

var _get2 = _interopRequireDefault(require("lodash/get"));

var _ValidationError = _interopRequireDefault(require("./ValidationError"));

var _genericValidator = _interopRequireDefault(require("./validators/genericValidator"));

var _booleanValidator = _interopRequireDefault(require("./validators/booleanValidator"));

var _numberValidator = _interopRequireDefault(require("./validators/numberValidator"));

var _stringValidator = _interopRequireDefault(require("./validators/stringValidator"));

var _arrayValidator = _interopRequireDefault(require("./validators/arrayValidator"));

var _objectValidator = _interopRequireDefault(require("./validators/objectValidator"));

var _dateValidator = _interopRequireDefault(require("./validators/dateValidator"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var typeValidators = {
  Boolean: _booleanValidator.default,
  Number: _numberValidator.default,
  String: _stringValidator.default,
  Array: _arrayValidator.default,
  Object: _objectValidator.default,
  Date: _dateValidator.default
};
var EMPTY_ARRAY = [];

var _default = function _default(rule, value) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var rules = rule._rules;
  var valueIsUndefined = value === null || typeof value === 'undefined';

  if (typeof rule._required === 'undefined' && valueIsUndefined) {
    // Run all _custom_ functions if the rule is not set to required or optional
    rules = rules.filter(curr => curr.flag === 'custom');
  } else if (!rule._required && valueIsUndefined) {
    // Short-circuit on optional, empty fields
    return Promise.resolve(EMPTY_ARRAY);
  }

  var type = rule._type;
  var validators = typeValidators[type] || _genericValidator.default;
  var tasks = rules.map(validateRule);
  return Promise.all(tasks).then(results => results.filter(Boolean)).then(_flatten2.default); // eslint-disable-next-line complexity

  function validateRule(curr) {
    if (typeof curr.flag === 'undefined') {
      return Promise.reject(new Error('Invalid rule, did not contain "flag"-property'));
    }

    var validator = validators[curr.flag];

    if (!validator) {
      var forType = type ? "type \"".concat(type, "\"") : 'rule without declared type';
      return Promise.reject(new Error("Validator for flag \"".concat(curr.flag, "\" not found for ").concat(forType)));
    }

    var itemConstraint = curr.constraint;

    if (itemConstraint && itemConstraint.type === rule.FIELD_REF) {
      if (!options.parent) {
        return Promise.reject(new Error('Field reference provided, but no parent received'));
      }

      itemConstraint = (0, _get2.default)(options.parent, itemConstraint.path);
    }

    var result = validator(itemConstraint, value, rule._message, options);
    return Promise.resolve(result).then(processResult);
  }

  function processResult(result) {
    if (Array.isArray(result)) {
      return (0, _flatten2.default)(result.map(processResult));
    }

    var hasError = result instanceof _ValidationError.default;

    if (!hasError) {
      return null;
    }

    var results = [];

    if (result.paths.length === 0) {
      // Add an item at "root" level (for arrays, the actual array)
      results.push({
        level: rule._level,
        item: result
      });
    } // Add individual items for each path


    return results.concat(result.paths.map(path => ({
      path,
      level: rule._level,
      item: result
    })));
  }
};

exports.default = _default;